\chapter{Concepts}
\labelchapter{concepts}
%-----------------------
\beginchapter
%-----------------------
This chapter will talk about different concepts or strategies used to navigate and/or edit a diagram. As only a limited number of previous research done on this topic could be found. Most of these concepts are either deducted from the investigation of tools or completely new.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Section Start %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Keyboard Navigation}
The most common way used to navigate diagrams are implemented and used with the help of some sort of pointing devices. These provide a very easy way to the user to pinpoint the shape/node he/she wants and just select it with the pointing device in use. This is also the most natural way of selecting things as it relatively emulates the normal behavior of human beings towards objects, the user will move his hand towards the object he/she wants to deal with, and then grab it (or click it). On the other hand, navigation using pointing devices can be a little bit hard for the developer to detect the exact edges of the shape and toggle the selection in the right way. It also can be very challenging for people with some disabilities in their hands that prevents them from using pointing devices accurately if not at all. Although navigation using pointing devices is the closest to the natural way people would like to select things, in some points one could think of a better way to do it because in diagrams, connections between shapes means some sort of relation between them, and when navigating a diagram using a pointing device, the interpretation of the meanings of the connections are left to the user. For example, if the user wants to select the parent node of another certain node, he/she will have to look at the connections, determine where is the parent, and then select it. This piece of information cannot be processed by the computer in case of the use of pointing devices, because the selection is only triggered based on the coordinates ignoring any information about previously selected nodes/shapes and their relation or connections to their neighbor nodes.

\paragraph{}
This is why we thought about implementing diagram navigation in another way, using only the keyboard. This will allow people that are not able to handle pointing devices to navigate diagrams as easy as others do, and will also allow the processing of the meanings of the connections to be done by the computer. Also keyboard keys could be mapped to voice commands which will allow people with further disabilities to use the system. Three ways to navigate the diagram using the keyboard were investigated.

\subsection{Tab Navigation}
The first way is Tab Navigation. This is the most trivial way of navigation using the keyboard. The user will navigate using a single key (most probably the Tab key), with each press, the selection will change between the nodes/shapes based on a predefined order, probably the order they were created, and thus leaving the user with no choice but to follow that order. A backward tab navigation can also be implemented through using Shift+Tab and traversing the list in the reversed order. Tab navigation can be implemented in a dual mode to navigate shapes or connections. Tab navigation is sometimes very inefficient, especially when nodes/shapes created in sequence are laid out dispersedly on the screen.

\begin{table}[H]
\begin{center}
\begin{flushleft}
\footnotesize
{+ indicates that this function can be done using this navigation method.}\\
\end{flushleft}
	\begin{tabular}{| l | l | l |}
	\hline
	Selecting Shapes & Selecting Connections & Navigating Non-Connected Graphs \\ \hline
	+ & +* & + \\ \hline
	\end{tabular}
\begin{flushleft}
\footnotesize
{* only if implemented in a dual mode}
\end{flushleft} 
\caption{Tab Navigation - Function Summary}
\labeltable{tab_navigation_function_summary}
\end{center}
\end{table}

\subsection{Arrow Keys Navigation}
% consider using 2 arrow keys in combination providing 8 directions instead of 4
An improvement on the Tab Navigation would be to give the user the ability to control where the selection will go. This can be done using the Arrow Keys Navigation, where the user will use the arrow keys to change the selection throughout the diagram in the direction he prefers. This navigation poses a challenge to the developers choosing the way they will sort the nodes in order to retrieve the closest node in the direction the user wants to navigate in. This method can completely replace the Tab Navigation. But still this mode of navigation doesn't interpret the meaning of the connections nor select the target node/shape based on its connections.
Arrow keys navigation can either be implemented to navigate nodes/shapes or to navigate connections. Both will be implemented exactly the same way.

\begin{table}[H]
\begin{center}
\begin{flushleft}
\footnotesize
{+ indicates that this function can be done using this navigation method.}\\
\end{flushleft}
	\begin{tabular}{| l | l | l |}
	\hline
	Selecting Shapes & Selecting Connections & Navigating Non-Connected Graphs \\ \hline
	+ & +* & + \\ \hline
	\end{tabular}
\begin{flushleft}
\footnotesize
{* only if implemented in a dual mode}
\end{flushleft} 
\caption{Arrow Keys Navigation - Function Summary}
\labeltable{arrow_keys_navigation_function_summary}
\end{center}
\end{table}

\paragraph{}
As mentioned before, this method can provide a challenge for the programmer in the way he will choose to simulate something that would seem natural for human beings. Four approaches were defined to implement this method of navigation.


\subsubsection{Approach 1: Smallest Deviation}
In this approach the main aim is to minimize the deviation from the direction the user selected, in other words, try to move exactly in the direction of the arrow key the user pressed. The result of this approach can easily be simulated by drawing a line (horizontal or vertical) starting at the initial node and extending in the direction of the arrow key the user pressed, and then selecting the closest node to that line. Although this is the most logical way, sometimes it doesn't yield preferable results. This might happen when there is a node in the direction of the arrow key the user presses that is very far away but almost exactly on the virtual line in that direction. This node will get selected although it might be even out of the view of the user. %ADD FIGURE HERE

\subsubsection{Approach 2: Quadrants}
As the name for this methods suggests, the screen is divided into four quadrants and only the nodes in the quadrant corresponding to the arrow key pressed are considered. The considered nodes are sorted relative to their absolute distance from the central node. Then the one with the smallest distance will be selected. This method yields results that are much more natural because it considers both, the direction and the distance to the target node. The only drawback of this method is that it prioritizes the nodes in one quadrant based only on their distance from the central node and doesn't give any further priority to nodes based on their relative position to the central node. %ADD FIGURE HERE
\begin{spacing}{2}\end{spacing}
\noindent
{\bf Pseudo-Code:}
\par
\begin{algorithmic}
\STATE list $considered$
\FORALL{node $i$ in graph}
	\IF{$i$ is in quadrant}
		\STATE $considered$.insert($i$)
	\ENDIF
\ENDFOR

\FORALL{node $i$ in $considered$}
	\STATE $i.distance\gets sqrt(($x$-$xi$)\superscript{2}+($y$-$yi$)\superscript{2})$
\ENDFOR

\STATE $considered$.sort($distance$)
\STATE select($considered$[0])
\end{algorithmic}

\subsubsection{Problems with Approaches 1 and 2}
To overcome the drawbacks of the first and second approaches one has to think about why they failed to produce accurate decisions at the first place. The Smallest Deviation approach used only the direction of the arrow key pressed to be the base for its decision, and the Quadrants approach used a partial information about the direction (not the exact direction but one of four spans of directions dividing the whole space into four spans each 90 degrees) and the information about the distance. If we consider how a point can be define in some well known coordinates system, we'll then notice that the first two approaches failed to yield valid results due to the non-complete information they base their decision on. The first two approaches take polar coordinates system data (angle and distance) but both don't take the complete data. The Smallest Deviation approach takes only direction information while neglecting the distance, and the Quadrant approach takes the distance into account while taking into account only a partial information about the direction. Thus, to construct a system that is able to yield correct results, it has to take complete position information for the target nodes. This doesn't have to be restricted to angle and distance like in Polar coordinates system, but it can be in x position and y position like in the Cartesian coordinates system, or any other complete information from any coordinates system.

\paragraph{}
Two approaches were thought of to compensate the deficiencies in the {\it Smallest Deviation} and {\it Quadrant} approaches these are approaches 3 and 4.

\subsubsection{Approach 3: Smallest Deviation and Quadrants in conjunction}
This approach uses both {\it Smallest Deviation} and {\it Quadrants} in conjunction. This could be achieved by giving numbers to the sorted lists out of the {\it Smallest Deviation} and  {\it Quadrants} and then for each node sum those two numbers, and then select the node with the smallest sum. %ADD FIGURE AND/OR EXAMPLE HERE

\subsubsection{Approach 4: Weighted Coordinates Differences}
This approach considers something else other than the distance and the direction but that carries the same information. Like the data from the Cartesian coordinates system, x position and y position. The x and y represent the relative position of the target node from the initial node in the x and y directions respoectively. These could be used in a weighted manner to calculate the factor that will be used to sort the nodes. For example we could calculate the x difference and the y difference, multiply each by a constant weight for all nodes, and then sum both weighted differences, then sort the nodes based on the sum. The pseudo-code for this method is represented in\refcode{weighted_coordinates_differences}. ``weight\_big'' and ``weigh\_small'' are two value representing a smaller and a bigger tolerance respectively. These values are used to be multiplied to the difference of the coordinates in a specific direction. If the weight was big, then the resulting value will be greater, thus making the difference in this direction affecting the result more than the other. These two weight values are used each in the right place to give more importance to the direction of the arrow key the user pressed.

\inccode{pseudo-code/weighted_coordinates_differences}{Pseudo-Code: Weighted Coordinates Differences}{weighted_coordinates_differences}

\subsection{Smart Navigation Following Connections}
A way of navigation that takes into account the connections between the nodes/shapes is the Smart Navigation Following Connections. %[REWORK THE FOLLOWING PARAGRAPH, SOUNDS CONFUSING] 
In this navigation mode, the user can switch selection between a connected part of the diagram based on the connections between the nodes/shapes. As this method of navigation follows connections, It will only allow the navigation of a connected subgraph without having the ability to go to other parts that are not connected to the subgraph being navigated. Thus it will have to be accompanied with another navigation method to ensure the presence of this functionality. Taking the direction of connections, in directed graphs/diagrams\footnote{In graph theory, directed graphs are the ones that have directions for their edges.}, into consideration is possible here, allowing the user to follow the connections in their specified directions only adding more semantics into the navigation of the diagram. In other words, considering the directions of the connections while navigating will make this navigation based on the meaning of the diagram not only its look.

\paragraph{}
In this method, the user is given the option to switch between the connections going in and/or out from the currently selected node/shape, then he will choose the connection he/she would like to follow. The user selects the shape where he would like to start the navigation from then clicks the ``navigation-next-connection-clockwise'' or the ``navigation-next-connection-counterclockwise'' button which will cause one of the connections going in or out of this shape to be selected as well. With each press of the previously mentioned buttons, the selected connection will change in a clockwise or counter clockwise matter respectively taking the center to be the node the user initially selected. Once the user has settled on the connection he would like to follow he will press the ``navigation-follow-connection'' button, this will allow him to follow this connection. Following the connection can be implemented in two almost completely different ways, Single Stepped and Double Stepped.

\begin{itemize}
\item {\it Single Stepped Navigation}
\par \noindent
In the single stepped navigation, once the user chooses to follow a connection, the selection is moved only one step away from the initial node, selecting only the connection the user chose to follow. This situation is illustrated in\reffig{smart_navigation_initial_state} and\reffig{smart_navigation_final_state_single_step}, representing the initial state and the final state, respectively, of the single stepped smart navigation.\\
This method of navigation allows the handling of the connections as normal shapes giving the possibility to other connections to be connected to them like in\reffig{smart_navigation_single_step_advantage}. This might not be possible in other types of navigation.\\
The single steps this method involves slow down the navigation compared to other methods like the Double Stepped navigation as it requires double the number of actions from the user thus also requiring more time.

\incfig{smart_navigation_initial_state/smart_navigation_initial_state.pdf}{Smart Navigation Initial State}{smart_navigation_initial_state}{width=5cm}

\incfig{smart_navigation_final_state_single_step/smart_navigation_final_state_single_step.pdf}{Smart Navigation Final State - Single Stepped Navigation}{smart_navigation_final_state_single_step}{width=5cm}

\incfig{smart_navigation_single_step_advantage/smart_navigation_single_step_advantage.pdf}{Single Stepped Advantage}{smart_navigation_single_step_advantage}{width=5cm}

\incfig{smart_navigation_final_state_double_step/smart_navigation_final_state_double_step.pdf}{Smart Navigation Final State - Double Stepped Navigation}{smart_navigation_final_state_double_step}{width=5cm}

\begin{table}[H]
\begin{center}
\begin{flushleft}
\footnotesize
{+ indicates that this function can be done using this navigation method.}\\
\end{flushleft}
	\begin{tabular}{| l | l | l |}
	\hline
	Selecting Shapes & Selecting Connections & Navigating Non-Connected Graphs \\ \hline
	+ & + & - \\ \hline
	\end{tabular}
\caption{Single Stepped Smart Navigation - Function Summary}
\labeltable{single_step_smart_navigation_function_summary}
\end{center}
\end{table}

\item {\it Double Stepped Navigation}
\par \noindent
The double stepped navigation, on contrary to the single stepped navigation, totally jumps over the connections and only targets shapes. When the user chooses a connection to follow, the selection moves from the initial shape to the shape at the other end of the connection where the final state has only the latter shape selected. This is illustrated in\reffig{smart_navigation_initial_state} and\reffig{smart_navigation_final_state_double_step} representing the initial and final states respectively. Using the double stepped navigation to select nodes is not possible, although this might be complemented using something like arrow keys navigation in two different modes, one for connections and one for shapes.\\
Also as the double stepped navigation cannot reference connections, thus the connections that act like shapes will normally cause problems. For example, in\reffig{smart_navigation_single_step_advantage}, if we have node 1 selected it will not be possible to move to node 3, because for this graph to be realized, the connection between node 1 and node 2 also has to be considered as a shape so that other connections could connect to it.

\begin{table}[H]
\begin{center}
\begin{flushleft}
\footnotesize
{+ indicates that this function can be done using this navigation method.}\\
\end{flushleft}
	\begin{tabular}{| l | l | l |}
	\hline
	Selecting Shapes & Selecting Connections & Navigating Non-Connected Graphs \\ \hline
	+ & - & - \\ \hline
	\end{tabular}
\caption{Double Stepped Smart Navigation - Function Summary}
\labeltable{double_step_smart_navigation_function_summary}
\end{center}
\end{table}


\end{itemize}

\subsection{Diagram Navigation Completeness}
To ensure that the navigation method implemented is complete, using only the keyboard, we have to make sure that using these methods of navigation we can visit each and every node/shape and connection in the diagram considering all types of diagrams of course.

\paragraph{}
To do that we have to consider visiting all nodes and connections in connected as well as non connected diagrams or graphs \footnote{In the graph theory, a connected graph is a graph having a path from any node to any other within the graph.}. We have then to consider including the ability to move between non connected subgraphs, the ability to select connections and the ability to select nodes. To implement such a complete keyboard diagram navigation we have to implement a set of navigation methods in conjunction. The exact set is subject to change based on the application and the user preferences. But to ensure that it is complete a set has to be chosen so that it fulfills all the criteria in\reftable{combinations_complete_diagram_navigation}.

\paragraph{}
The possibilities are either to implement arrow keys navigation with a single mode only for shapes, along with a single stepped smart navigation. Or an arrow keys navigation with dual mode, one for nodes and one for connections, along with a double stepped smart navigation. Or one could implement the two types of arrow keys navigation, either separate, or both integrated into a single navigation mode. But this will not offer navigation based on nodes/shapes connections to others.
\begin{table}[H]
\begin{center}
\begin{flushleft}
\footnotesize
{Each colum represents a possible combination for a complete navigation}\\
\end{flushleft}
	\begin{tabular}{| l | l | l | l |}
	\hline
	Arrow Keys Navigation Single Mode (shapes only)	&   & + &   \\ \hline
	Arrow Keys Navigation Dual Mode			& + &   & + \\ \hline
	Single Stepped Smart Navigation			&   & + &   \\ \hline
	Double Stepped Smart Navigation			&   &   & + \\ \hline
	\end{tabular}
\caption{Possible Combinations for Complete Diagram Navigation}
\labeltable{combinations_complete_diagram_navigation}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Section End %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Section Start %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Diagram Editing Using the Keyboard}
As for diagram navigation, the most common way to edit a diagram is done using pointing devices. The user can easily point the tool he wants, and drags on the canvas to draw the shape. But again, away from pointing devices, how to accomplish this task using only the keyboard might be a little challenging. Different paradigms of keyboard diagram editing are discussed below.\\
To fully edit a diagram we need to provide five functionalities, choosing the shape, adding, editing, deleting, and connecting shapes.

\subsection{Editing Using Accelerators}
Accomplishing the previously mentioned functionality is possible through various ways. One of those ways can be done using Keyboard Accelerators. Using this method, the user will have to press a combination of keys representing the action he wants to perform on the diagram. Then he might be required to enter some other necessary arguments.

\begin{itemize}
\item {\bf Choosing the Shape}
\par \noindent
The user chooses the shape mainly based on the first combination of keys he will press. For example he could press Ctrl+R for rectangle. This will choose the rectangle drawing tool, and activate it to be ready for drawing.

\item {\bf Adding shapes}
\par \noindent
After choosing the shape that will be drawn, there are two options for how to place the shapes, one or both can be implemented.
	\begin{itemize}
	\item {\it Dragging}
	\par \noindent
	The user will then use the keyboard arrow keys to move the cursor along with another key to simulate the mouse click and make the drag. This method simulates the mouse movement using the keyboard. Thus it doesn't emphasize productiveness, using the mouse in most cases will be easier, but that's only valid if the user has the ability to use it. And also as it simulates a movement on the screen, if the actions done by the mouse could be mapped to voice commands, those commands will be hardly usable.
	
	\item {\it Arguments}
	\par \noindent
	The other way would be to type in a set of arguments representing the position and the size of the shape to insert. The required input position of the shape doesn't have to be always the absolute position. It can be a position relative to a selected shape or it can be a just a direction from a selected shape, e.g. under the selected shape or above it. Those directions from the selected shape can be supplied using the arrow keys for example. This way can be easily mapped to voice commands to supply the arguments and is of course faster to deploy the shape, but on the other hand is not good for visualizing the output before adding the shape.
	\end{itemize}

\item {\bf Editing Shapes}
\par \noindent
	The user can edit the shapes in a way relatively similar to placing it. The user would first select the shape he wants to edit, then press a combination of keys representing the property he wants to edit for that shape, then he will enter the arguments representing the values for the property to change. In another way of implementation, which is actually similar to the menu based editing, after pressing the combination of keys representing the property to edit, a pop-up dialog will be displayed containing fields corresponding to the property to edit. The user will edit those values using the keyboard and then press the Return key to apply the changes.

\item {\bf Deleting Shapes}
\par \noindent
	Deleting shapes is an easy task to implement using accelerators. Probably the user will press the delete (or another) key after selecting the shape he wants to delete, and the shape will be deleted.

\item {\bf Connecting Shapes}
\par \noindent
Connecting shapes is not an easy task to implement using keyboard accelerators, but some work around can be done to accomplish it. Such work around can be by requiring the user to select the two shapes he wants to connect, and then press the combination of keys for the connection, here the direction of the newly created connection can be determined based on the order of selection of the shapes. Another way to do it is to select a shape,  then press the connection accelerator, and navigate to the other shape and press the Return key for example, this will allow defining a direction for the connection directed from the initial shape towards the latter selected one. This way will also give the ability to give the user a preview of how the to-be-created connection will look like while he is navigating to the end shape. To enable more than one type of connections, which is highly needed in some kinds of diagrams like UML diagrams for example, one could assign one accelerator for each type of connection. Or on the press of the connection accelerator, a menu with the types of connections available could be displayed to the user to choose from.

\end{itemize}

\subsection{Menu Based Editing}
\labelsubsection{menu_based_editing}
In menu based editing, the user will have a menu key that he will press to access all the functions he can perform on a shape. For example, after selecting a shape, the user will press the menu key, and that would display either a menu or a dialog, both leading to someplace where the user can edit the object properties.

\begin{itemize}
\item {\it Menu with the properties}
\par \noindent
after selecting a shape, once the user presses the menu key, a drop down menu will be displayed containing all possible actions on that shape. The user will then choose the item he wants and presses the Return key for example.

	\begin{itemize}
	\item {\bf Choosing the Shape}
	\par \noindent
	with no shapes selected, the user will press the menu key, and a menu with all possible shapes will be displayed, the user will choose the shape he needs and hit the Return key. The shape will be drawn with the default options and in a default position.
	
	\item {\bf Adding Shapes}
	\par \noindent
	After the shape is drawn in the default position and with default options, the user can edit its properties to customize it to what he needs. The properties should of course contain the position and the size of the shape.

	\item {\bf Editing Shapes}
	\par \noindent
	To edit the shape, the user will simply have to select the property he wants to edit from the drop down menu, then a dialog containing the value of this property will be displayed where the user can edit the value, and the changes are applied when Return is pressed.

	\item {\bf Deleting Shapes}
	\par \noindent
	deleting the object here will be as simple as choosing delete from the menu and hitting the Return key.

	\item {\bf Connecting Shapes}
	\par \noindent
	After selecting a shape the user can select an entry ``Connect To'' from the menu, then he will enter the navigation mode, and navigate to the other shape then press the Return key. There can be a sub-menu to the ``Connect To'' entry representing the different types of connections.
	\end{itemize}

\item {\it Properties Dialog}
\par \noindent
The other way to implement the menu based editing, is to display a dialog with all the properties of the object and their values on the press of the menu key. This dialog will contain the real values for the properties of the object. The user will then access those values directly and change them.

	\begin{itemize}
	\item {\bf Choosing the Shape}
	\par \noindent
	If the user hits his menu key with no shapes selected, the property dialog will be opened with default values for the shape. This property dialog will include the ability to select the type of shape to add, its position and size. The user can then change those default values exactly as in {\it Editing shapes}.

	\item {\bf Adding Shapes}
	\par \noindent
	After the user is done editing the properties values in the dialog, he will hit the Return key and a new shape will be added with the properties the user specified.

	\item {\bf Editing Shapes}
	\par \noindent
	With a shape selected, the user will press his menu key, a popup dialog will be displayed with the values of the properties for the current shape. The user will be able to edit those values and the changes will be apply on pressing the Return key.

	\item {\bf Deleting Shapes}
	The property dialog might contain a button for deleting an object.

	\end{itemize}

\end{itemize}

\subsection{Command Based Editing}
Editing diagrams using commands is the most feasible interactive method between all discussed methods unless the user is not familiar with remembering commands and exact syntax and order of arguments, then, the menu based editing will be the best for him. It requires actions from the user to edit/create a diagram, but at the same time it is easy to automate these actions or redo them through saving/executing the same commands. Here the user is presented with a text field where he can enter his commands, and then press the return key, which will cause the input command to be executed.

\begin{itemize}
\item {{\bf Choosing the Shape} and {\bf Adding Shapes}}
\par \noindent
Both actions are accomplished in one step, the command will represent the tool used as well as the minimal amount of arguments, and an ID for the shape. The shape will then be added using this minimal amount of arguments and the rest of the properties will be set to defaults.\\
The commands for adding shapes can be something like this:\\
rectangle x-pos y-pos width height

\item {\bf Editing Shapes}
\par \noindent
The user can reference the shapes with their IDs previously entered and execute commands on them. There should be commands to change every possible property of the shape.\\
For example to change the color the user can enter:\\
color Obj-ID R G B A

\item {\bf Deleting Shapes}
\par \noindent
simple commands can exist to delete the shapes.\\
delete Obj-ID

\item {\bf Connecting Shapes}
\par \noindent
Connecting shapes also is not that hard, the user will simply enter the connection command followed by the two objects IDs to connect.\\
connect con-type Obj1-ID Obj-2ID

\end{itemize}

\paragraph{}
There can be a saved shape ID that the user is not allowed to use as normal shape IDs. This shape ID can be something like ``selected'' for example, and it would always refer to the currently selected shape(s). This way, if the user doesn't remember the shape ID of a specific shape, he can navigate to it, and use ``selected'' instead.

\paragraph{}
The commands the user enters can be saved as macros or scripts that can be later executed to do the same actions on any diagram. Also some lay-outing and scripting commands can be added, such as commands to auto-layout the shapes, or to execute an external script in the current diagram.

\subsection{Scripting}
Scripting can be implemented in two different ways, one is to give a descriptive text input for what will the diagram include and how it will look like, but not including the exact positions and sizes of the shapes. This is not considered diagram editing and will not be discussed here. The other is to form the diagram through steps corresponding to executing commands that define the shapes and connections in sequence. Those commands could of course contain commands that are not help lay-outing the diagram or automate some parts of the creation. MAKE THIS MORE CLEAR, NOT UNDERSTANDABLE

\begin{comment}
BY CHRISTIANE
 I think you should also discuss a combination of all the methods mentioned. I think a combination would be the most feasible. You should somehow state this. 
The combination of keyboard accelerators and menu based editing is already done in many tools.
Maybe you should also briefly discuss the keyboard editing via navigating through standard tool-bars and menus by arrow keys or tab key. Of course, this is no good method. But as it is used in many tools it should be discussed here, I think. Furthermore, this method has the advantage that really every functionality of a diagramming tool could be activated if it is placed in some menu or toolbar.
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Section End %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
